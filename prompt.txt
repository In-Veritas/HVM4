TASK 1:

In HVM4, lambdas can be unbound, meaning their variables occur outside of their
bodies, and dups "float" in the global heap, meaning they don't even have a
body. Because of that, variables that occur outside of their bodies are printed
as '_', which is wrong, and dups aren't even printed, at all.

For example, consider:

@main = λk.
  ! F = λx; // creates an unbound lam/var pair: F = λa.$x.a and x = $x
  ! K &L = k; // clones k with a &L label
  #Tup{x, F, K₀, K₁, λv.v}

Running it with `./clang/main bad.hvm4` results in:

λa.#Tup{_,λb.λc.b,a,a,λa.a}

This is wrong, since:

- the '_' variable is not matching the 'λc' lambda

- the dup node is not showing up

- it shows 'a' twice instead of the dup node vars

Instead, the correct output should've been:

λa.λb.#Tup{d,λc.λd.c,A₀,A₁,λe.e}
! A &L = a;

Notice that:

- each lam/dup-bound variable has a globally unique name (instead of being lexical)

- all visible dups are printed after the term

- λ-bound variables are lowercase (a, b, c, ...), dup-bound variables are uppercase (A, B, C, ...)

- unscoped variables work fine

To achieve that, we must *modify* the pretty printer to include a global
variable naming scheme, anchored by the location of λ bodies and dup exprs.
Whenever we find a VAR or LAM, we assign a fresh, globally unique name to the
pair, keyed by the LAM's body location. That works because both the VAR and the
LAM store that same location on the val() field of their Terms. Then, we just
print the variable with that unique name, and the lambda with that unique name.

As for dups, since they *float* in the global scope, we must also *detect* dups
when we reach CO0/CO1 variables. When that happens, we set a globally unique
name for that dup (which will be used by the DUP, by the CO0, and by the CO1).
Then, after the term is printed, we proceed to print all DUPs we discovered.
Note that this might cause new DUPs to be discovered, and printed later. That's
fine and expected. Just make sure we avoid loops (i.e., a DUP can only be
discovered once) and we're fine. Remember that we key DUP's by the location
of the dup'd expression, which is what is stored on CO0/CO1 variables.

Finally, we must modify snf to NOT substitute bound vars by names.

Note that many tests will break after this change. DO NOT RUN THEM.

Just implement this change and assert the test above prints as expected.

Then come back to me for next steps.

TASK 2:

On the README.md (HVM4's documentation), we often use a "step by step"
evaluation notation to teach how this system works. For example:

```
! f &= λx.(x + 1);
(f₀(10), f₁(20))
------------------------------ DUP-LAM
! b &= (&{$x0, $x1} + 1);
((λ$x0.b₀)(10), (λ$x1.b₁)(20))
------------------------------ APP-LAM, APP-LAM
! b &= (&{10, 20} + 1);
(b₀, b₁)
------------------------------ OP2-SUP, DUP-NUM
! b &= &{(10 + 1), (20 + 1)};
(b₀, b₁)
------------------------------ OP2-NUM, OP2-NUM
! b &= &{11, 21};
(b₀, b₁)
------------------------------ DUP-SUP
(11, 21)
```

Your goal is to add a new option to this repository, -D, which will perform a
step by step reduction instead of a single pass reduction. To do so, you must
update snf to remember the root term and, instead of calling wnf() normally, it
should, when the global STEP_BY_STEP variable is set, perform a loop where it
calls wnf() repeatedly, until the interaction count doesn't change. Also we must
add a global ITRS_LIMIT which, when reached, causes wnf to stop reducting and
just return. We just set ITRS_LIMIT to current itrs + 1 when calling wnf inside
snf. We print each intermediate state.

Note that we must also be able to print global dups. For example, in the program
above, it would probably sometimes print just:

(_₀(10), _₁(20))

Because _₀ and _₁ would be identified as unbound dups. This is wrong. Instead, we
must update the printer to properly capture 


